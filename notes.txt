9/28/16
SoftDev:

Aim: Requesting assistance

request object
	stores information about incoming requests.
ex:
from flask import Flask, render_template, request

ex (from flasktest.py):
print request.headers
return render_template( "form.html" )

prints:
Referer: http://127.0.0.1:5000/
Content-Length:
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0
Connection: keep-alive
Host: 127.0.0.1:5000
Upgrade-Insecure-Requests: 1
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Content-Type:
Accept-Encoding: gzip, deflate

HTML:
<form action="/msg/">
<textarea name = "message" rows = "6" cols= "40"></textarea>
Python:
@app.route( "/msg/" )
def auth():
    print request.headers
    print request.args
    print request.args["message"]
    return "You good"


9/29/16
Systems:

Aim: Make so

Make
	Create compiling instructions and setup dependencies
	Standard name for the file is the makefile.

	Syntax:
		<target><dependencies>
		TAB<rules>


	strtest: stringy.c
		 gcc stringy.c

	clean:
		rm *~


	make clean would remove all emacs save files
	(files with ~ at the end of filename).


SoftDev:

Aim: Dont forget to include POSTage
DN: Open up yesterday's flask app

request.headers
	HTML headers sent from borwser
request.method
	the request method (GET/POST)
request.args
	the arguments in a query string from a GET request
request.form
	the arguments sent in a POST request
request.args and request.form are immutable dictionaries.

the u in the dictionary is unicode (string)

9/30/16
SoftDev:

Aim: Always Serve Your Passwords With A Side of Hashbrowns

Hash function
     function designed to take in an arbitrary amount of data and return a fixed
      size sequence of bits called a "hash digest" or simply, hash.

      Hash digests are useful for storing certain kinds of sensitive information.

Creating a had digest in python:
	 hashlib
		python module for generating has digests with different
		algorithms

		ex:
			md5 (bad), sha1, sha224, sha256, sha384, and sha512 (spits more bytes)

		ex:
		import hashlib
		hashlib.md5("12345")
		hashlib.md5("12345").digest() -> returns as string as attempted
		ASCII (looks messy w/ "\x")

		hashlib.md5("12345").hexdigest() -> gives savable string as hex

		hashlib.sha1("12345").hexdigest() -> longer
		hashlib.sha512("12345").hexdigest() -> much longer hex values

10/5/16
Systems:

Aim: If these files won't behave, we'll have to separate them!

DN: Demo.

crazy one line version of strlen:
int len(char *s) {
    return *s?1+len(*++s):0;
}

dw strcat:
char * dwstrcat( char * s1, char *s2 ) {
     char * p;
     p = s1 + len( s1 );
     dw strcpy(p);
     }

separate compilation:
	 You can combine multiple c files into a c program by
	 including them all in one gcc command.
	     ex:
		gcc test.c string.c foo.c woohoo.c

	 You cannot have duplicate function or global variable names
	 across these files.
	 	ex: main()


one solution: make file w/o main
    ex: #include "dwstring.h"
    	void main() { ... }


	$gcc dwstrtest.c dwstring.c

SoftDev:

Aim: C is for Cookie, but Sessions are Secure

DN: Demo.

How to keep track who is logged in:

Cookies are files that websites will save to your web browser
to store information on a local machine.

Useful for keeping track of persistent information like login credentials.

They have been around for a long time (not new).

A session is a securely signed cookie. They are encryted and cannot be modified
by the local machine.

A session object works exactly like a dictionary:
  add data to a session:
  session[KEY] = DATA
  	       ex: session['user'] = request.form('user')

  remove data from a session:
  session.pop(KEY)
	ex: session.pop('user')

  In order to encrypt session, need a private key in our app:
     APP.secret_key = <RANDOM STRING>

     		    get random data: os.urandom(32)
		    returns 32 random bits of data as string.

10/6/16
Systems:

Aim: malloc & free: The dynamic duo!

     gcc -c dwstring.c main.c  = compile but not make it executable

     -> dwstring.o main.o

     gcc dwstring.o main.o

     -> a.out


.o files can be linked together with .c files through gcc

gcc -o specify name of executable file

gcc would try to make file executable, gives error if "main" is missing.


void * malloc(int x)
	   memory is not initialized (allocates x bytes of memory from the heap)
	   generates generic pointer return, able to typecaste to appropriate
	   pointer.

free(void *ptr)
     releases previously allocated memory.

void * calloc(int n, int x)
     allocates n * x bytes of memory
     ensures each bit = 0
     generates generic pointer return, able to typecaste to appropriate pointer.

void * realloc(void *ptr, int x)
     takes a pointer and changes the amount of memory allocated to given block

     ptr must be a pointer to the beginning of an allocated block of memory, but it does not have to be the original pointer.


SoftDev:

Aim: Url binding is the art of redirection

     app.secret_key = os.urandom(32)
     that could log out all of the users when app is restarted.

     ex:
     print url_for( "login" )
     uses associated function to build correct url

     redirect
     Flask fxn that will redirect a call to one route to a different response
     used in combination with url_for
     	  ex:
		redirect( url_for('login') )

10/7/16
Systems:

Aim: Structural Programing

void *
     the dynamic memory functions deal in arbitrary blocks of memory.
     There is no regular type associated with the block.

     void * is considered to be a pointer to a 1 byte block of memory,
     so pointer arithmetic will be based on 1.

ex:
  int *p;
  p = malloc( 5 * sizeof(int) ); //same as calloc( 5, sizeof(int) )

  p[0] = 2;
  printf( "p[0]: %d\n", 0[p] );

ex:
  int *ip;
  ip = (int*)malloc( 20 * sizeof(int) );


Struct
	A collection of values in a single data type
	struct { int a; char x; } s; sizeof(s) -> 8 (does units of 8 bytes)
	|-----------------------|
	  s is a type that has an int and char

	  here, s is a variable of type struct { int a; char x; }


	struct foo { int a; char x; };
	       in this example, foo is a prototype for this kind of struct
	       to be used later.

	struct foo s;
	we use the . oparator to access values in a struct:
	   ex:
		s.a

	We use the . operator to access a value iside a struct
	   s.a = 10;
	   s.x = '@';

	   . binds before *
	     to access data from a struct pointer you can either:
	     	struct foo *p;
		p = &s;
		(*p).x;
			or...
		p->x;

10/11/16
Systems:

Aim: Get Dem Bugs

What is wrong with this fxn?
struct node * insert_front( struct node * n, int i ) {
       struct node new;

       new.i = i;
       new.next = n;

       return &new;

}
The fxn is reasonably okay, but it is stack memory (new and its variables will be popped).
The only time memory is allocated dynamically is by using malloc, calloc, ect.

Typedef
	provide a new name for an existing data type
	typedef <real type> <new name>;

	ex:
		typedef unsigned long size_t;
		size_t x = 139; //really an unsigned long

		typeof short[10] list;
		list a;
		typeof char * String;

		typedef struct foo { int a; char x; } bar;


gdb (GNU Debugger)
    allows you to get detailed information about a program while it is running.

    ex: gdb a.out

    quit = quit gdb
    list = lines of code around error

    ex: break 10 = set a breakpoint at line 10

    print <VAR> = prints a variable

    backtrace = show the currect stack


valgrind
	debugging tools specializing in memory values.


	valgrind --leak-check=yes ./a.out
		 checks memory leaks


9/13/16
Softdev:

Aim: All your data are belong to us.

Relational database
	   Database that stores information as a collection of tables.

	   Field: column data in a RDB
	   Record: row in a RDB
	   Data can be linked between tables based on field values.

ex:
Students
name:	| id:
-------------------
amy	| 0
reo	| 1
emma	| 3


Class
name:	| student id:	| grade
------------------------------------
softdev	| 0		| 100
softdev	| 1		| 100


the id is related to the id in the students table


SQL (Structured Query Language)
    Standard language designed to work with relational databases.

    Is used for many major db programs, though the implementations may not
    (mostly are not) compatible.

    MySQL, PostgreSQL, SQLite, Oracle are different SQL implementations.

SQLite
	SQL implementation that relies entirely on functions calls in the parent
	program. There is no database server.

	All database information is stored in a single file.

	Data is dymanically typed as values are inserted into a table.

Basic SQLite Operations
      CREATE TABLE
      	     Add a table to a database
	     CREATE TABLE <name> (<column name> <data type>, ... )
	     	    The data type will help to convert entered values to a
		    suggested type.

		    TEXT, INTEGER, REAL, NUMERIC, BLOB
		    	  NUMERIC will default to an integer, but can be a float.

			  BLOB means no suggested type.

ex:
	$ sqlite3 school.db
	...>CREATE TABLE students (name TEXT,...);
	.tables = show the tables
	INSERT INTO students VALUES ("amy", 0);
	INSERT INTO classes VALUES ("softdev", 0, NULL );


	Columns can be given a PRIMARY KEY attribute.
	denoting that every entry in that column is unique and cannot be NULL

	Columns can be given NOT NULL attribute, denoting that no entry can be NULL.
	INSET INTO
	      Insert a record into a table
	      INSERT INTO <name> VALUES ( <field 1>, <field 2> ... )
	      	     Will add a record to a table matching the values to the columns in order.

	NULL can be used in any entry.

	SELECT * FROM <name>; = select everything from a table

SQLITE Shell commands
       .quit
       .tables
       .header on|off
       .mode column|csv|list|html|insert|line|tabs

10/17/16
SoftDev:

Aim: sqlite, the low-fat alternative to SQL

python sqlite module
        import sqlite3

        connect
		open/create an sqlite database.

    		If the database does not exists, create it.
		   db = sqlite3.connect(<db name>).

        cursor
		Create a database cursor object that will allow you to perform
		operations of the databse.

		c = db.cursor()

        execute
		cursor method to perform the provided SQL operation, given as a
		string.

		c.execute( <SQL statement> )

	commit
		database method to save changes to the db

		db.commit()

	db.close()


	formatting strings in python:
		   '(' + x + ', ' + y + ') is a point'
		       =
		   '(%d, %d) is a point'%(x, y)


		   %d = decimal integer
		   %f = floating point
		   %s = string

	ex:
	command = 'INSERT INTO students VALUES ("%s", %d, %d'%(students['name'], ...

SQL SELECT Statement
    Used to get data from a database
    Creates a results table based on the query
    SELECT <column 1>, ... FROM <table 1>, ...;
    	   Will return a new table containing only the requested columns from the requested
	   tables.

	   ex:
		SELECT name FROM students;
		SELECT * FROM students; -> gives everything from students
		SELECT name, id, code FROM students, courses; -> needs to specify
		    solution:  ->  students.id

10/18/16
Systems:

Aim: C, the ultimate hipster, using # decades before it was cool

ex:
	#include "link_list.h"
	->if you include 2 .h files, where one .h file includes another .h file,
	the .h file would be included twice. That is problematic.

#
	used to provide preprocessor instructions
	these directives are handled before the compler really kicks in.
	NOT regular c syntax
	gcc basically goes and copies content of the header file to where "include" is

	#include <library> or "LIBRARY"
		 link libraries to your code.

	#define <NAME> <VALUE>
		"find and replace" all occurances of NAME with VALUE

		ex:
			#define TRUE 1
				TRUE is not a variable, and doesn't get replaced in a string.

		macros:
			#define SQUARE(x) x*x (not a fxn)
			...
			int y = SQUARE(9); -> int y = 9 * 9;
			    DOESN'T COMPUTE 9*9!!

		conditional statement:
		#ifndef (if not defined) <IDENTIFIER>
		<CODE: deal with whatever is in here>
		#endif

		if the identifier has to be defined ignore all the code up until the
		endif statement.

		ex:
			#ifndef LINK_LIST_H
			#define LINK_LIST_H
			...

		also:
			#define FOO 5
			a[FOO] would be fine since FOO would be replaced.

	rand(), srand(int), sranddev()
		srand(int) = sets a seed, can be used as srand( time(t sec since epoch) )
			   time(NULL) needs #include <time.h>
		sranddev() = seed rand() with random number
			   (linux has a "file" that generates random values)
		rand() = random number generator

SoftDev:

Aim: WHERE did I put that data?

WHERE
	allows you to put restirctions on the results of a SELECT statement.

	ex:
		SELECT * FROM courses WHERE mark < 65;

		can use single = sign for equality test

	ex:
		select name, students.id, courses.id, code, mark from students, courses where students.id = courses.id and mark > 70;
		name        id          id          code        mark
		----------  ----------  ----------  ----------  ----------
		kruder      1           1           systems     75
		kruder      1           1           ceramics    99
		dorfmeiste  2           2           softdev     75
		dorfmeiste  2           2           ceramics    98
		sasha       3           3           greatbooks  85
		digweed     4           4           softdev     75
		bassnectar  6           6           ceramics    90
		bassnectar  6           6           systems     90
		bassnectar  6           6           softdev     99
		TOKiMONSTA  7           7           systems     88
		TOKiMONSTA  7           7           softdev     85
		jphlip      8           8           systems     98
		alison      10          10          systems     85
		alison      10          10          softdev     80


10/19/16
Systems:

Aim: A bit of operators

>> and << are binary operators.

int i = 30;
i = i>>2;
    i -> 8 (shifted values 2 bits to the "right", and added 2 0s in the front)
i = i<<2;
    i -> 28 (NOT 30)

~ negation
  flips every bit

  ex:
	00001 -> 11110

| or, & and
  ex:
	a | b -> 10010 | 01010 -> 11010
	a & b -> 10010 & 01010 -> 00010

    perform or/and for each pair of bits in (a, b)

^ xor
  ex:
	a ^ b

	perform xor for each pair of bits in (a, b)



10/21/16
Systems:

Aim: File this under useful information.

File permissions:
     read, write, and execute

     3 digit binary #s or 1-digit octal
     100 -> read only
     111 -> read, write, and execute


     3 permission areas: owner/user, group, other
     3-digit octal number
     	     ex: 644 -> user: read + write, group+other: read
	     default: -rw-r--r-- (644)

	     directories are also files (that contain a list of files they contain)
	     (look = read, add files = write, cd into directory = execute)
	     your id is in the metadata (data about data) in the file.


     File table:
     	  A list of all the files that is used by a program while it is running.
	  Contains basic info such as location and size.

	  has a limited size, which is a power of 2 and commonly 256 files (not bytes), and
	  getdtablesize() will return this size.

	  each file is given an integer index (starts at 0) and referred to as file descriptor
	  3 files are always open in the table:
	    	  0 or STDIN_FILENO: stdin
		  1 or STDOUT_FILENO: stdout
		  2 or STDERR_FILENO: stderr (standard error)
		  (they are links)

10/24/16
Aim: Opening up a world of possibilities

open/close
	-open: takes path string, what type of access (ex append) and optionally permission. returns int of -1 if unsuccessful.
	-close: closes file associated with handle and returns 0 if unsuccessful and -1 if error.

read/write
	-read: read( int rd, void *buf, int count )
	       read operation that attempts to read count bytes from buf associated with rd.
	-write: writes count bytes from buf to the file associated with rd.


open - <fcntl.h>
     add a file to the file table and returns its file descriptor

     if fails, -1 is returned, extra error infrmation can be found in errno.

     	errno is an int variable that can be found in <errno.h>, using strerror (in string.h)
	on errno will return a string decription of the error

	open( <PATH>, <FLAGS>, <MODE> )

	mode
		only used when creating a file. set the new files permissions using a 3 digit octal # (have a leading 0)

	ex:

	fd = open( "tester", O_RDONLY ); -> 3 if successful (0, 1, and 2 are taken)
	printf( "error: %d - %s", errno strerror(errno) );

	flags
		Determine what you plan to do with the file.
			 O_RDONLY
			 O_WRONLY
			 O_RDWR
			 O_APPEND
			 O_TRUNC
			 O_CREAT (create)
			 O_EXCL: (exclusive) only works when combined with O_CREAT, will return error if file exist


Each flag is a number, to combine flags we use bitwise or
     O_WRONLY = 1
     O_APPEND = 8
     O_WRONGLY | O_APPEND = 00001001


close - <unistd.h>
      remove a file from the file table (0 if successful)

      close( <FILE DESCRIPTION> );

10/24/16
Systems:

Aim:

umask - <sys/stat.h>
      set the file creation perission mask
      By default, created files are not given the exact permissions provided in the mode argument to open. Some permissions are automatically shut off. (ex: 0666 != rw-r--r--)

      Umask is applied by using bitwise negation on the mask, then bitwise and and-ing it to the mode
      new_permissions = ~umask & mode

      default umask = 0022.


So here, we get:
   umask:  000 010 010

   ~umask: 111 101 101
   & mode: 110 110 110
   -------------------
   result: 110 100 100

umask( <MASK> )
       ex: umask( 0000 ); -> everything is on
       	   umask( 0111 ); -> no execute permission

Read = take data from storage and dump into memory
read - <unistd.h>
     read( <file descriptor>, <buffer>, <amount> )
     read( fd, buff, n )

     same errno stuff ( -1, ect. ) as open
     read n bytes from the fd's file and put that data into buff

     returns the number of bytes actually read (if successful).
     buffer must be a pointer (doesn't naturally have to be a string).
     	    	 -can read integers if the file has actual numbers


write - <unistd.h>
      "twin" of read
      write n bytes from buff into fd's file

      returns the number of bytes actually written. Same errno stuff as open/read.
      buffer must be a pointer.


10/27/16
Systems:

Aim: Seek and ye shall find

-write raw byte data into txt file
       reads the int one byte at a time and attempts to read it as ASCII

lseek - <unistd.h>
      Set the current position in an open file
      lseek( <FILE DESCRIPTOR>, <OFFSET>, <WHENCE> )

      offset = # of bytes (can be negative)
      whence = where to measure offset from
      	     SEEK_SET
		offset is evaluated from the beginning of the file

	     SEEK_CUR
		offset is relative to the current position in the file

	     SEEK_END
		offset is evaluated from the end of the file

	returns the # of bytes the current position is from the beginning of the file

ex:
	int b = write(fd, r, sizeof(r) );

	lseek( fd, 0, SEEK_SET )
	int x;
	read( fd, &x, sizeof(int) );
	printf( "x: %d\n", x );
	printf( "b: %d\n", b );



10/28/16
Systems:

octal permission: ex: 100644
      1 is a regular file, 4 is a directory


Softdev:

Stuff we can add:
being_edited = boolean when user in middle of editing story

11/1/16
Systems:

Aim: Where fo compsci priests live? - In directory!

sprintf:
	print formated string into a string.

calloc guarantees terminanting null.

convert octal to string rwx:

perms[0] = (mode & 0b11000000) >> 6;
perms[1] = (mode & 0b111000) >> 3;
perms[2] = (mode & 0b111);

or:
110 100 100

if( mode & 256 )
    perm_string[0] = 'r';


Directories:
	A *nix directory is a file containing the names of the files within the
directory along with basic information like file type.

	Moving files into/out of a directory means changing the directory file.
not actually moving any data.

opendir - <dirent.h>
	open a directory file.

	This will not change the cwd, it only allows your program to read the
contents of the directory file.

	 opendir( <PATH );

	 returns a pointer to a directory stream (DIR *)

closedir - <dirent.h>
	 closes the directory stream and frees the pointer associated with it.

	 closedir( <DIRECTORY STREAM> )

readdir - <dirent.h>

	readdir( <DIRECTORY STREAM> )

	Returns a pointer to the next entry in a directory stream, or NULL if all entries have already been returned.

	struct dirent - <sys/types.h>
	       Directory struct that contains the information stored in a directory.

SoftDev:

Aim: Extending your template knowledge.

Extending HTML templates
	  any template can be inherited by others
	  To extend a template: {% extends "<TEMPLATE>" %}

	  You can define sections to override inside.
	  ex: (content is a name)

	  {% block content %}

	  {% endblock %}

Note about directories (Systems):
	// . refers to directory itself and .. refers to the parent directory


11/3/16
Systems:

Aim: Input? fgets about it!

stat provides metadata (doesnt open file)

getcwd - <unistd.h>
       get the current working directory (cwd) of a program

       getcwd( <STRING BUFFER>, <SIZE> )
       	       copies the path to the cwd into the buffer argument (char * )
	       copies at most SIZE characters of the path

       ex:
       char path[100];
       path[99] = 0;
       getcwd(path, 99);
       printf( "current directory: %s\n", path ); -> gets absolute path

chdir - <unistd.h>
      change the working directory of a program

      chdir( <PATH> )
      	     returns 0 if successful, -1 (errmo) if not
	     keep track of file paths when using chdir!

      chdir( ".." );
      getcwd(path, 99);
      printf( "current directory: %s\n", path ); -> now prints parent directory


Command Line Arguments:

	int main( int argc, char *argv[] )
	program name is considered the first command line argument

	argc
		number of command line arguments

	argv
		array of command line arguments


	ex:
	while( argc ) {
	       argc--;
	       printf( "%d: %s\n", argc, argv[argc] );
	}

scanf - <stdio.h>
	scanf( <FORMAT STRING>, <VAR 1>, <VAR 2>, ... );

	ex:
	int i; float f;
	scanf( "%d-%f", &i, &f );


11/4/16
Systems:

Aim: Sending mixed signals

fgets - <stdio.h>
    Read in from a file stream and store it in a string
    fgets(<DESTINATION>, <BYTES>,< FILE POINTER>)

    File pointer
        FILE * type, more complex than a file descriptor
        stdin is a FILE * variable

    Stops at newline, EOF, or the byte limit.
    If applicable, keeps the newline character as part of the string, appends NULL after

Signals
    Limited way of sending information to a process.
    kill
        Command line utility to send a signal to a process
        $ kill <PID>
            Sends signal 15 (SIGTERM) to PID

the command "ps" shows a list of running processes that were run from a terminal
	"ps -ax" shows ALL processes

PID is process id
All process information can be found in /proc/<PID>

11/7/16
Systems:

Aim: Are your processes running? - Then you should go out and catch them!


Processes
	Every running program is a process. A process can create subprocesses,
	but these are no different from regular processes.

	A processor can handle 1 process per cycle (per core). "Multitasking"
	appears to happen because the processor switches between all the active
	processes quickly.

pid
	Every process has a unique identifie called the pid.
	pid 1 is the init process
	each entry in the /proc directory is a current pid.

getpid() - <unistd.h>
	 returns current process' pid

getppid() - <unistd.h>
	 returns current process' parent pid

Signals
	Limited way of sending information to a process.

	kill
		command line utility to send a signal to a process

		$kill <PID>
		      sends signal 15 (SIGTERM) to PID

		$kill -9 <PID> will give a different signal
		      (Killed: 9 is different from the default Terminated: 15)

		killall [-<SIGNAL>] <PROCESS>
			sends sigterm (or signal if provided) to all processes
			with process as the name

Signal handling in c programs <signal.h>
       kill
	kill(<PID>, <SIGNAL>)
		    returns 0 on success or -1 (errno) on failure.

Sighandler
	To intercept signals in a c program you must create a signal handling
	function.

	Some signals (like SIGKILL) cannot be caught.

	static void sighandler( int signo )
		Must be static, muct be void, must take a single int parameter.
		static: the function can only be called from within the file it
		is defined.

	in main attatch:
	   signal( SIGINT, sighandler );

sleep(1); wait 1 second before "spamming"


11/10/16
Systems:

Aim: What the fork?

fork: "forks" a new process (make a sub (new) process)
(ex: bash: command -> subprocess ->bash)

The child process runs on its own. They don't share information and
can have some intercations (signals).


fork() - <unistd.h>
       Creates a separate process based on the current one, the new process is
       called the child, the original is the parent.

       The child process is a duplicate of the parent process. All parts of the
       parent process are copied, including stack and heap memory, and
       the file table.

       Returns 0 to the child and the child's pid to the parent or -1 (errno).
       (the child gets a return value (0) from fork and the parent will get the
       pid of the child or -1 (if fails-no child).)

       If a parent process ends before the child, the child's new parent pid is 1.


       ex:
       int f;
       printf(pid)
       f = fork();
       printf(pid) -> now run by 2 processes (parent does not always execute 1st (more like
       child finishes, then parent comes back))
       if the parent finishes its function, and the child has not, the ppid would print 1.

       look at return value of fork to assign different tasks.


11/15/16
Systems:

Aim: Wait for it...

f = fork();
if( f == 0 )
    printf("I'm a child: %d, parent: %d\n", getpid(), getppid());
else
    printf("I'm a parent! f = %d\n", f);

printf( "almost done!\n" );


But what about threads you ask?
    A quick note on threads: A thread is a separate executable entity similar
    to a child process, except a thread is not a standalone process.

    It does not have its own memory space, instead it shares its parent's
    memory. But shares info more quickly.


to make child run before parent, we can fake it:
   use: sleep(1);

   better:
	wait - <unistd.h>

		Stops a parent process from running until any child has provided
		status information to the parent via a signal.
		(usually the child has exited)

		returns the pid of the child that exited, or -1 (errno)

		wait( int *status )
		      The parameter (status) is used to store information about
		      how the process exited.

ex:
else {
     int status, r;

     r = wait( &status );
     printf("I'm a parent! f = %d\n", f);
     printf("wait returned: %d  status: %d\n", r, status);
     printf("WEXITSTATUS: %d\n", WEXITSTATUS(status) );
}


Softdev:

Aim: Stuylin'

CSS - Cascading Style Sheets

    Created to separate the presentation of an html/xml page and its content

    Basic syntax:

    	  PROPERTY: VALUE;

	  ex:
		color: lightsteelblue;


	  There are 3 ways to incorporate css into a page;
	  inline, style sheet, external style sheet.

	  inline: least useful
	  <TAG style="CSS CODE">

	  ex:
	  <p style="color: green; font-size: 2em;">...</p>

11/16/16
Systems:

Aim: Time to make an executive decision.

execlp:
	takes command line args as strings.

	int execlp( const char *filename, const char *arg, ... )

execvp:
	takes command line args as an array.

	int execvp( const char *filename, char *const argv[] )

	run executables by filename and argv is an array of null-terminated
	strings to provide a value of the argv in the main function of the
	executable file.
	(appropriate arguments to the file/command line arguments).

	if no slash exists in filename, will look through the PATH environment
	variable.

Both:
	<unistd.h>

	run executables and REPLACE CURRENT PROCESS.
	takes over process including pid

	returns -1 and set errno only if theres an error.


ex:
  char* file = "ls";
  char * arg[3]; //command line arguments
  arg[0] = "ls";
  arg[1] = "-al";
  arg[2] = NULL;

  int i = execvp( file, arg );
  printf( "Return: %d - error: %s\n", i, strerror(errno) );


ex:
  execlp( "ls", "ls", "-l", NULL );


SoftDev:

Anything in the <head> loads first.

External Style Sheet:
in <head>:
   <link rel="stylesheet" type="text/css" href="STYLE FILE">


11/17/16
Systems:

Aim: Let's take this to delimit!

specify path with execl
execl( "/bin/ls", "ls", "-l", NULL );

char * command[3]; - > array of pointers, but is NOT a null terminated string
     *the 3 pointers are going to assigned to immutable strings*

ex:

	command[0] = "ls";
	command[1] = "-l";
	command[2] = NULL;

	//command[1][1] = 'a'; -> will create an error if added
	/*
		char command[3][4]; -> ([][][][])([][][][])([][][][])
		//can't do s[4] = "hello"; -> only during declaration
		//must use string functions instead
	*/

	execvp( command[0], command );


strsep - <string.h>

       Used for parsing a string with a common delimeter

       strsep( <SOURCE>, <DELIMETER> )

       Locates the first occurrence of the delimeter in a string and replaces
       that character with NULL
       *only strsep with mutable strings!*

       Returns a pointer to the beginning of the original string,
       sets the source string to the string starting at 1 index past the
       location of the new NULL.

       Since the source variable's value is changed, it must be a pointer to a
       string.

       To parse again, loop it.

ex:

	char line[100] = "hello-this-is-cool";
	char *s = line;
	char *p;
	while( s ) {
	       p = strsep( &s, "-" );
	       //no new memory is used (s is mutable pointer)

	       printf( "s: %s\n", s );
	       printf( "p: %s\n", p );
	}

SoftDev:

Aim: Stay classy, css.

class ex:
      <h2 class="new_chapter bold">...</h2>

Classes are specified using a . before the class name.

ex:
	.hello {
       	       font-family: "Times New Roman", Times, serif; //specific -> general
	       }

id ex:
   <div id="main_content">...</div>

ids are specified using a  # before the id name.


11/22/16
Systems:

Aim: Redirection; how does it ... SQUIRREL

File Redirection
     Changing the usual input/output behavior of a program

Command line redirection
 >
	redirects stdout to a file
	overwrites the contents of the file

	<COMMAND> > <FILE>
	ls > file_list

 >>
	redirects stdout to a file by appending


cheap text editor:
      cat > foo

      takes stdin and puts them into a file caled foo

2>
	redirects stderr to a file
	OVerwrites the file (2>> appends)

0: stdin
1: stdout
2: stderr

&>
	redirect stdout and stderr

<
	redirects stdin from a file
ex:
	cat > line; ls -a -l
	./a.out < line (from executor)
	immediately executes command. as soon as it reads it, it already gets
	the input, so it doesn't print "what would you like to do?".

| (pipe)
	redirect stdout from one command to stdin of the next
	ls | wc (takes output of ls to the stdin of wc)


dup2 - <unistd.h>
     redirect one file descriptor to another

     dup2( fd1, fd2 )
     	   Redirects fd2 to fd1
	   Lose any reference to the original fd2, that file is closed.


0: stdin
1: stdout -> closed -> foo.txt
2: stderr		|
3: foo.txt		v (directs to 3, lose reference to stdout)


dup - <unistd.h>

    Duplcates an existing entry in the file table
    Returns a new file descrptor for the duplicate entry

    dup(fd)
	returns the new file descriptor

ex:
	dup(1) -> creates a new file descriptor (stdout)
	dup2(3, 1) -> now foo.txt is in 1, but stdout is still in the file table at 4.




11/23/16

fgets GETS EVERYTHING (INCLUDING THE \N YOU ENTER)

*(strchr(line, '\n')) = NULL; sets the '\n' from input to NULL

alternate way of using strsep: while(cmd[i++] = strsep( &s, " " ))

11/28/16
SoftDev:

Aim: After being framed, you might need to take a REST

Tips for using frameworks:
     Many files have .min equivalents, which contains the same code without any extra formatting.

     jquery is a popular javascript library used in many frameworks.

     The order in which you include javascript is important. They are loaded sequentially.

ex:
	<script src="jquery-3.1.1.js"></script>


Javascript in <head> or at the end of <body>?
	   Yet another programmer holy war

	   Advantages to head:
	   	      scripts will definitely be loaded bofore anything else, so page elements that need scripting will be attached.

	   Disadvantages to head:
	   	      scripts will take longer to load (not compiled)

	   Advantages to end of body:
	   	      Page content loads much faster

	   Disadvantages to end of body:
	   	   Page might look fully loaded while scripts will continue to be downloaded.

REST API:

     Application Program Interface.

     Way to interact with other existing program.

     published set of protocols that can be used to have your program with others.

     REST (Representational State Transfer)
     	  APIs that transmit data back after receiving an http[s] request.
	  Returned data can be in various formats, most common are html, xml, json.

JSON (Javascript object notation)
     Standard way of representating data. Can be easily translated into a python dictionary.

ex:
	https://api.nasa.gov/planetary/apod?api_key=....

	takes one variable (api key) in the url


11/29/16
Systems:

Aim: Sharing is caring!

Shared memory - <sys/shm.h>, <sys/ipc.h>, <sys/types.h>
       A segment of heap memory that can be accesssed by multiple processes.

       Shared memory is accessed via some key that is known by any process that needs to access it.

       Shared memory does not get released when a program exits.

       5 shared memory operations:
       	 Create the segment (once)
	 Access the segment (once per process)
	 Attach the segment to a variable (once per process)
	 Detach the segment from a variable (once per process)
	 Remove the segment (once)

Shared memory is not about child-parent relations, can be accessed by any process.

shmget
	Create or access a shared memory segment.

	Returns a shared memory descriptor (similar to a file descriptor), or -1 if it fails.

	shmget( key, size, flags )

		key
			unique identifier for the shared memory segment ( like a file name ).

		size
			How much memory to request

		flags
			includes permissions for the segment.

			combine with bitwise or

			IPC_CREAT: create the segment
				   If segment is new, will set value to all 0s.

			IPC_EXCL: fail if the segment already exists and IPC_CREAT is on


ex:
	int sd = shmget( 24601, 4, IPC_CREAT | 0644 );

shmat
	Attach a shared memory segment to a variable

	Returns a pointer to the segment, or -1 (errno).

	shmat( descriptor, address, flags )
	       descriptor
			the return value of shmget

		address
			if 0, the OS will provide the appropriate address

		flags
			Usually 0, there is one useful flag

			SHM_RDONLY: makes the memory read only


SoftDev:

Aim: Web crawling pythons

Making and parsing a REST call in python

       urlib2
		Library to handle urls

		.urlopen
			u = urllib2.urlopen(<URL>)

			Open a url to be read by your program

			Just opens url, doesn't get data yet.

		.geturl()
			returns the atual url (in case of redirects)

		.info()
			returns the http/s header information

		.read()
			returns the contents of the target webpage, as a string
				e.g., if image file, returns bytes of the image.



json
	Library to work with json data

	.loads(<STRING>)
		d = json.loads(<STRING>)
		Turns a json object string into a dictionary

	.dumps(<DICTIONARY>)
		Turns a python dictionary into a json object string


11/30/16
Systems:

Aim: Memes

command: ipcs (interprocess communications) -> shows shared memories

shmdt
	Detach a variable from a shared memory segment

	Returns 0 upon success or -1 upon failure

	shmdt( pointer )
	       pointer
		The address used to access the segment

	example
		shmdt( P )

Detaching revokes access -> gives segmentation fault if still accessign after detach.

shmctl
	Perform operations on the shared memory segment

	can remove segment operation

	Each shared memory segment has metadata that can stored in a struct (shmid_ds)
	Some of that data stored: last acces, size, pid of creator, pid of ast modification.

	shmctl( descriptor, command, buffer )

		descriptor
			return value of shmget

		commands:
			IPC_RMID: remove a shared memory segment

			IPC_STAT: populate the buffer (struct shmid_ds) with information

			IPC_SET: set some of the information for the segment to the info in buffer

		example:
		struct shmid_ds d;
		shmctl( sd, IPC_RMID, &d )



ftok - <sys/ipc.h>

     Generate a key useful for IPC functions

     ftok( path, x )

     	   path
		a path to some file, the file must be accessible by the program

	   x
		an int used to generate the key

	   The same path and x will always generate the same key
	   Combines file + int, pseudo-random


     sd = shmget( ftok("dir/file", 12), 1024, IPC_CREAT | 0664 );


12/5/16
Systems

Aim: How do we flag down a resource?

System V IPC != POSIX.

Semaphore: keeps processes from colliding when interacting w/ same memory.

	   created by Edsger Dijkstra

	   IPC construct used to control access to a shared resource (like a file or shared memory).

	   Essentially, a semaphore is a counter that represents how many processes can access a resource at any given time.

	   		If a semaphore has a value of 3, then it can have 3 active "users".

			If a semaphore has a value of 0, then it is unavailable.

			A mutex is a semaphore with a value of 1.

	Most semaphore operations are "atomic," meaning they will not be split up into multiple processor instructions.
	     Create a semophore
	     Set up initial value
	     	 Up(S)/V(S)
			Release the semaphore to signal you are done with its associated resource

			pseudocode: S++

		Down(S)/P(S)
			Attempt to take the semaphore.

			If the semaphore is 0, wait for it to be available.

		pseudocode:
			While(S==0)
				block (when a program halts operation)
			S--

		Remove a semaphore (when done)

Semaphores in C - <sys/types.h> <sys/ipc.h> <sys/sem.h>

	   semget
		Create/get access to a semaphore.
		Not the same as Ups(S), it does not modify the semaphore.

		Returns a semaphore descriotpr or -1 (errno).

		semget( <KEY>, <AMOUNT>, <FLAGS> )
			KEY = unique identifier (use ftok)

			Aount = semaphore are stored as sets with potentially many semaphores together. This parameter sets the # of seiphores tocreate/get.

			FLAGS = includes permissions for the semaphore.
			      combine with bitwise or IPC_CREAT = create the semaphore and set value to 0, IPC_ESCL = fail if IPC_CREAT is on.

ex:
	int key = ftok( "makefile", 57 );
	int semed = semget( key, 1, IPC_CREAT | 0644 ); -> 544 = read+access (r + A).



12/6/16
Systems

Aim: What's a semaphore? - To control resources!

With a union, you're only supposed to use one of the elements, because they're all stored at the same spot.
This makes it useful when you want to store something that could be one of several types.
A struct, on the other hand, has a separate memory location for each of its elements and they all can be used at once.

Semaphore code
	  semctl - <sys/types.h> <sys/ipc.h> <sys/sem.h>

	  	 control the semaphore, including:
		 	 set the semaphore value
			 Remove the semaphore
			 Get the current value
			 Get information about the semaphore

		semctl( <DECRIPTION>, <INDEX>, <OPERATION>, <DATA> )

			Decription
				return value of semget

			Index
				The index of the semaphore you want to control in the semaphore
				set identified by the descriptor for a single semaphore set, 0

			Operation
				One of the following constants (there are others as well)

				IPC_RMID: remove the semaphore

				SETVAL: Set the value (requires DATA)

				SETALL: Set the value of every semaphore in the set (requires DATA)

				GETVAL: returns value

				IPC_STAT: Populate buffer with information about the semaphore (requires DATA)


			Data
				Variable for setting/storing information about the semaphore
				(data type: union semun)

				you have to declare this union in your main c file on linux machines

				union semun {
				      int val;
				      struct semid_ds *buf;
				      unsigned short *array;
				      struct seminfo *_buf;
				};

					val: used to set initial value
					buf: buffer for IPC_STAT


ex:
	int semid;
	int key = ftok( "makefile", 22 );

	semid = semget( key, 1, IPC_CREAT | 0644 );

	union semun su;
	su.val = 1;
	int i = semctl( semid, 0, SETVAL, su );
	i = semctl( semid, 0, GETVAL ); //doesnt need unon semun su
	i = semctl( semid, 0, IPC_RMID );


semop
	perform semaphore operations (like Up/Down)

	all operations performed via semop are atomic!

	semop( <DESCRIPTOR>, <OPERATION>, <AMOUNT> )
	       amount
			the amount of semaphores you want to operate on in the semaphore set

	       operation
			a pointer to a struct sembuf value

			  struct sembuf {
			  	 short sem_op;
				 short sem_num;
				 short sem_flag;
				 };

			sem_num
				the index of the semaphore you want to work on

			sem_op
				-1: Down(S)
				1: Up(S)

				any -/+ number will work, you will be requesting/releasing that value from the semaphore.

				0: Wait until the semaphore reaches 0.

			sem_flag
				Provide further options

				SEM_UNDO: Allow the OS to undo the given operation
					  Useful in the event that a program exits before it could relase a semaphore.

				IPC_NOWAIT: Instead of waiting for the semaphore to be available, return an error.



12/7/16
Systems

Aim: What goes up really should come down.

ex:
	srand( time(NULL) )
	int x = random() % 10;
	int semid = semget( ftok("makefile", 22), 1, 0 );
	printf("[%d] Before access, %d\n", getpid(), x );

	struct sembuf sb;
	sb.sem_num = 0;
	sb.sem_flg = SEM_UNDO;
	sb.semop = -1;

	semop( semid, &sb, 1 );
	prinf("[%d] I'm in!\n", getpid());

	sleep(x);

	sb.sem_op = 1;
	semop( semid, &sb, 1 );

	printf("[%d] I'm done!", getpid());

//processes all have to wait 8 seconds.


12/12/16
Systems

Aim: Ceci n'est pas une pipe
(This is not a pipe; this is a picture of a pipe)

ex:
	struct stat sb;
	stat( "story.txt", &sb );
	int size = sb.st_size;
	char * s = (char*) malloc(size);
	int fd = open( "story.txt.", ...


Pipe
	A conduit between 2 separate processes. (Not a network direction)
	Pipes have 2 ends, a read end and a write end.
	Pipes are unidirectional (a single pipe must be either read or write only in a process)

	You can transfer any data you like through a pipe using read/write

	Unnamed pipes have no external identification (pipes act like files)
		- limited to child-parent situations (childs inherit)


pipe - <unistd.h>
     Create an unnamed pipe

     Returns 0 if the pipe was created, -1 if not

     Opens both ends of the pipe as files.

     pipe( int descriptrors[2] )
     	   descriptors
		Array that will contain the descriptors for each end of the pipe.

ex:
		int fds[2];
		char s[20];

		pipe( fds );

		int fork();
		if( f = 0 ) {
		    close( fd[1] );
		    read( fds[0], s, sizeof(s) );
		    printf( "[child] recieved: %s\n", s );
		}
		else {
		     close( fd[0] );
		     sleep(3);
		     write( fds[1], "hello child", 12 );
		}

12/13/16
Systems

Aim: A pipe by any other name...

Pipe: flipping decriptors DOESN'T work!

Name pipes
     A.K.A. FIFOs

     Same as unnamed pipes except FIFOs have a name that can be used to identify them via different programs.

     Like unnamed pipes, FIFOs are unidirectional.


     mkfifo
	shell command to make a FIFO

	$mkfifo <pipe name>

pipe: prw-r--r--

multiple reading / writing in pipes: gives confusion on what you are recieving.
	 (cat pipe)/(cat > pipe)

after connection is established, removing pipe does nothing (conduit is created already)

      mkfifo - <sys/types.h> <sys/stat.h>
      	     c funciton to create a FIFO

	     Returns 0 on success and -1 on failure

	     Once created, the FIFO acts like a regular file, and we can use open, read, write and close on it.

	     mkfifo( <name>, <permissions> )

	     FIFOs will block on open until both ends of the pipe have a connection.


SoftDev

Aim: Learning to write in script

javascript
	Programming language originally designed to augment html and to be run locally on a web browser.

	No direct relationship with java, though both have similar syntax.

	Dynamically typed - variable types are rpvoded at runtime (like python).

	Most development will be done through a web browser's console.

	console.log()
		There is no built in i/o. console.log() will display a string to the console.

		"undefined" means that the variable is undefined

	C-style syntax

	Variable basics: var (decimals -> doubles)
		 can also be a number, string, arrays/lists, and dictionary (object)
		 booleans: true/false (lowercase)

Document Object Model (DOM)

	 javascript derives most of its utility through being able to interact with html and xml documents.

	 The DOM is an API for interacting with html. It provides a structure that we can interact with and can be manipulated by functions.

	 Pages are represented as trees.

Selecting HTML elements
	  document.getElementById(<ID>) -> will return the first one
	  document.getElementsByTagName(<TAG>) -> list
	  document.getElementsByClassName(<CLASS>) -> list



12/14/16
Systems

Aim: Always remember to tip your servers.


Server/Client Program Paradigms
	      Handshake
		A prodcedure to ensure that a connection has been established

		Both ends of the connection must verify that they can send and recieve data to and from each other.


Basic handshake procedure:
      1) Server creates a FIFO (well known pipe).
      2) Server wait for a connection (use open)

      3) client, create "private" FIFO
      4) Client connects to server and sends the private IFO name.

      5) Client waits for a message from the server.
      6) Server recieves a passage and can remove WKP (well known pipre).

      7) Server connects to silent FIFO, sends a initial ackonowledgement mesage.

      8) Client receives server's message, removes private (connection is there).

Softdev

Aim: Functional code

     	document.getElementById(<ID>) -> will return the first one
	document.getElementsByTagName(<TAG>) -> list
	document.getElementsByClassName(<CLASS>) -> list


	They get nodes and display it toString();

Manipulating DOM elements

	list.remove() removes the node.
	.innerHTML -> changes content between the tags
	document.createElement( <HTML TAG NAME> ) -> adds a node
	.appendChild( <ELEMENt> )
	.setAttribute( <NAME>, <VALUE> )
	.getAttribute( <NAME> )
	.addEventListener( <EVENT>, <FUNCTION> ) -> every node can have a listener attached to it

Functions in javascript!

	  javascript is functional. Like Scheme (Racket)!

	  Functions are first class objects that can be used like any other value.

	  like lamba (fxn that creates fxn)
	       function() creates anonymous functions

	       var foo = function() { console.log("yo"); }; -> function() is a statement

	  b.addEventListener( "click", function() { alert("ANNOYING!"); } ); -> must have a function value (can't be just alert())
 -> Thats because functions have return values, alert as second argument -> means call alert -> put return value as event listener (alert has no return, so attached no function (undefined))

The other example, the function "returns" a function

b.addEventListener( "click", function(e) { console.log(e); } ); -> argument would be the event listener

var f = function(e) {
    console.log(e);
    console.log(this); -> gives DOM element (e.g. returns <button id="b">... )
};
b.addEventListener( "click", f ); -> f is bound to a function (doesn't need to list parameters)

12/16/16
Systems

[SERVER] WKP Created / [CLIENT] fifo created: pid()
[SERVER](/[CLIENT]) connection attempt/connetected to WKP
[SERVER] recieved: pid()
[SERVER] recieved: thank you

...

can fork server (server =  queen bee)


12/19/16
Systems

serverhandshake1(buffer) -> up to remove(WKP)
handshakemsg = ~10 char * length
buffer has name of WKP of client
serverhandshake2(buffer) -> simply the other half

SoftDev

performance.now() -> time to run program

12/20/16
Systems: 

Aim: Cisco in an hour

For 2 computers to communicate:
-Identification
-Send/recieve data
-Security
-Data packaging/message
-Composition
-Connection verification
-User interaction

OSI 7 Layer Model
	Used to help conceptualize the different parts of network connections.

	Built more layers on top of the lower layer -> application layer (top) (web browser/email client)

	The top layer is the most concrete, with each subsequent layer becoming more abstract (relying less on the physical connections and more on code).

	Layers:
		1. Physical
		2. Data link
		3. Network
		4. Transport
		5. Session
		6. Presentation
		7. Application

	When you work on a particular layer, you don't have to think about the other layers
	
Physical Layer
	How computers are physically connected (used copper wires to send high/low voltage, WiFi, bluetooth, cellular data, fiber optics, RFID, satellite ect.)

	Things like electrons running across wires, radio signals pulsing through the air...

	Brief history:
	
		Thicknet
			A single coaxial cable runs throughout the network, "vampire taps" go into the cable and leech the data out (cut a hole).
				ex: [computer]	[computer]	[computer]
					|		|		|
				--------------------------------------------------
		
		Thinnet
			A single coaxial cable runs throughout the network, T-Junctions used to splice connections
				ex: [computer]	[computer]	[computer]
					|		|		|
				-------[]--------------[]--------------[]-----------

		In Thicknet and Thinnet, all data is sent to all computers

		As we add more connections, the signal gets degraded (some electricity splits off to computer (each computer increases power drain in the entire system)).


12/21/16
Systems

Aim: Cisco in an hour. Part II: Electric Boogaloo

Token ring:
      Each computer is connected in a ring to each other: no signal degradation (signal gets transmitted around)
      	   Only one computer has command of network resources at a time (having the token) -> passes from computer to computer

	   The network sends a "token" throughout the ring, which contains the identity of the computer allowed
	   to use the network. All other computers must wait to use the network.
	   
	   No possibility of collisions.


Ethernet:		
	Multiple computers connect to a single hub or switch

	[computer]-	   -[computer]
		  |	   |
		  [swtich/hub]

	hub:
		broadcasts the data to ALL the computers

	switch:
		sends data to a specific computer

	The more computers added to an ethernet network, the greater the chance of collisions 

	WiFi: an ethernet hub that uses radio waves


Layer 2:
Data link layer
     point-to-point transmission between devices on the same local network

     (don't care about physical connection)

     Ethernet Connections:
     	      Each device is given a unique 6-byte MAC (Media Access Control) address.
	      this is set on each network card when it is made

	      (seperate and less regulated than IP address)


12/22/16
Systems

Aim: Cisco in an hour III: In 3-D!

Ethernet connections:
	Data is packaged into frames
		Ethernet frame:
		<prefix><dest><source><...><data><checksum>
		8B	6B	6B	6B  46-1500B   4B

		prefix: recognize the beginning of a new frame
			10101010 * 7 + 10101011

		destination/source: MAC address

		...: information about frame type


		checksum: data validation (insures data integrity) -> checks hash to checksum
			if doesn't validate, request to send back


	MTU: Maximum transmission unit
		1500B for ethernet


1/3/16
Systems

Aim: Cisco in an hour: A New Hope

Network Layer:
	transmission of data between two separate networks

	It is not concerned with whether or not data was sent successfully (connectionless).

	Major features of this layer are addressing, routing and packet forwarding.

IP (internet protocol) addresses
   IPV4: 4 byte address
   	 [0-225].[0-225].[0-225].[0-225]
	 (each set is an unsigned octet)

Routing is made easier by having IP addresses distrbuted in blocks.

traceroute will tell you about ex: google.com
	   1. our ip (also trial times (split into 3 packages))
	   2. gateway
	   3. switches (not shown)
	   4. finally gets to google

1/4/17
Systems

Aim: Cisco in an hour V for Vendetta

Network Layer
	Data is broken into packets (IPv4)
	
	<header info (2B)><packet length (2B)><fragment info (4B)><time-to-live(1B)><protocol (1B)><header checksum (2B)><source (4B)><destination (4B)><...(4B)><data (20-65,535B)>

	header info: packet type (IPv4/6), header length	

Data is chopped up into fragments -> fragment info e.g. 3rd fragment of 12
(network layer is not concerned with matching fragments together)

	 time to live: encode a number of maximum hops (device to device)
	      	       when packet dies, send response back
	
	protocol: (helpful for layer 4) TCP/UDP/...
		       
	unlike ethernet checksum, it is just for the header, NOT data.

	source and destination: IPv4 address, so 4B each

	...: optional information

	IPv4 MTU is 65,535B

	IPv6
		biggest difference is the address space goes from 2^32 -> 2^128

		written in 8 groups for 3 hexadecimal digits
			87ab : 301c : 2143 : ff87 : abcd : dead : feed

		leading 0s are ignored, consecutive 0-groups can be replaced with ::, but only once in an address.

	IPv4
		can be represented with 5 0-groups, 1 f-group (96 bits)
		followed by the regular IPv4 address (32 bits)

		:: ffff : 149.89.150.100

	jumbograms
		Increases the MTU to ~4.3 billion (2^32)

	other improvements in IPv6 make the protocol incompatible with IPv4

1/5/17
Systems

Aim: Cisco in an hour VI: The Undiscovered Country

Layer 4: Transport Layer
	Computer to computer connection over a network

	Unconcerned with the individual hops of layer 3 traffic

	Network port allows computer to respond to multiple connections
		ex: ip = street address, port = apt #

	65,535 ports. Ports < 1024 are well-known, reserved ports
		Each port corresponds to a particular service. ex: port 22 = ssh, http = port 80

	Regulated by the Internet Assigned Numbers Authority (IANA)


TCP
	Transmission Control Protocol
	
	Reliable connection + guarantees delivery of data

	Data is considered a continuous stream that arrives in the order it is sent (which may not be true in the network layer)
		(like reading a file)

	Connections are established using a 3-way handshake
		Server "binds" to a port and waits
		1. Client sends a SYN message to the server
		2. Server sends the client a SYN_ACK message (acknowledges message)
		3. Client sends an ACK message to the server
	
UDP
	User Datagram Protocol

	Does not require an explicit connection 

	Data is sent as discrete datagrams with a set size (as opposed to a continuous stream)

	Datagrams may be dropped or recieved out of order (like bittorrent)

	Assumes that any kind of error checking is handled at a later level
		Big advantage is speed (speed vs quality) - many videogames use this protocol

1/6/17
Systems

Aim: Cisco in an Hour VII: Adrian's Revenge

Remaining layers
	  5. Session
	  6. Presentation
	  7. Application

These layers are incorporated into programs that use network connections

Session layer represents end-to-end connections in a program (sockets).
	
Presentation layer represents how programs package transmitted data.
	     (APIs are pretty much the presentation layer)
	     
Application layer represents the programs that users interact with
	    ex: using a web browser, Spotify, playing a game ect.


Sockets - sys/socket.h, sys/types.h

	A socket is a connection between two computers created programatically
	  has 2 ends, each one consisting of an IP Address/Port pair.

	To use socket:
	   1. create the socket
	   2. bind it to an address and port
	   3. listen/initiate a connection (handshake)
	   4. send/recieve data

	3 + 4 will be different for TCP and UDP

	socket <sys/socket.h>
	       
	       Creates a socket and returns a socket descriptor (int that works like a file descriptor)

	       socket( <domain>, <type>, <protocol> )
	       	       domain: type of address, IPv4, IPv6...
		       	       AF_INET: IPv4
			       AF_INET6: IPv6
			       
			type: tcp/udp
			      SOCK_STREAM: tcp
			      SOCK_DGRAM: udp

			protocol
				Combination of domain and type settings

				If set to 0, the OS will set to correct protocol

		ex:
			int sd = socket( AF_NET, SOCK_STREAM, 0);


	bind - <sys/socket.h>

	     Binds the socket to an address and port

	     Returns 0 (success) or -1 (failure)

	     A server might bind to any incoming address but only a specific 
	     port, whereas a client would bind to a specific address and port.
 
		bind( <socket descriptor>, <address>, <address length> )
		      
		      socket descriptor: return value of socket
		
		      address: pointer to struct sockaddr_in
		      	       
			       sin_family: address domain (e.g. AF_NET)

			       sin_addr: 
			       		 IP address in binary
			       		 
					 INADDR_ANY: Any incoming connection

					 inet_aton( <string>, <address variable> )
					 	    
						    Will convert a string representing an ip address to the correct format and place it in the second parameter
						    
						    sin_addr.s_addr = INADDR_ANY; //any local ip address
					 
1/9/17
Systems

Aim: Socket to me

inet_aton -> use <arpa/inet.h>
	  Will convert a string representing an ip address to the correct format and place it in the second parameter.

sin_port
	htons( int )
	       returns the port in the correct order

	       uses big endian: most significant byte first

short s = 256;

00000001 00000000 -> big endian

00000000 00000001 -> little endian (all the way to the left, reverse the bytes, not the bits)

ex: Server Side

int sd;
int connection;
char buffer[200];

sd = socket( AF_NET, SOCK_STREAM, 0 )
struct sockaddir_in sock;
sock.sin_family = AF_INET;
sock.sin_addr.s_addir = INADDR_ANY;
sock.sin_port = htons( 9001 );

bind( sd, (struct sockaddr *)&sock, sizeof(sock) );

Client Side:
int sd;
char *host = "127.0.0.1"

sd = socket( AF_NET, SOCK_STREAM, 0 )
struct sockaddir_in sock;
sock.sin_family = AF_INET
inet_aton( host, &(sock.sin_addr) );
sock.sin_port = htons( 9001 );

bind( sd, (struct sockaddr *)&sock, sizeof(sock) );



listen (server only!!) <sys/socket.h>
       TCP server will listen to a socket and wait for an incoming connection

       listen (<socket descriptor>, <queue>)
       	      socket descriptor: return value of socket

	      queue = number of connections that can wait, doesn't work anymore (for backwards compatibility)

	      ex:
		listen( sd, 1 ) -> returns 0 or -1 (failure)

accept (server only!!) <sys/socket.h>
       set up a tcp connection

       handles the required 3-way handshake

       A complete socket has 5 important pieces of information, IP address and port # for both client and server, and protocol (tcp/udp)

       Once a client connection gets past listen(), accept creates a new socket with the client information added, and returns a descriptor to the new socket. 
       Original socket will still exist (as a listening socket)

       accept ( <socket descriptor>, <socket address>, <address length> )
		returns the socket descriptor of the new socket (arguments same as bind)

       	      socket descriptor: return value of socket

	      address: pointer to a struct pointer sockaddr_in
	      	       will contain the correct address information after the connection is made

	      length: pointer to a variable with the size of the address will be set after the connection is made.

ex:
	listen(sd, 1);

	struct sockaddr_in sock1;
	unsigned int socklen = sizeof(sock1);
	connection = accept( sd, (struct sockaddr *)&sock, &socklen ); 


1/11/17
Systems

Aim: Get more power from your sockets

Sockets in c

connect (client only!!) <sys/socket.h> <sys/types.h>
	Connect to another program over a socket

	Handles the client end of the 3 way handshake

	connect( <socket descriptor>, <address>, <address size> )
		address size is the same as in bind

ex:
Server Side:
read( connection, buffer, sizeof(buffer) );
Client Side:
connect( sd, (struct sockaddr *)&sock, sizeof(sock) );

Softdev

Aim: Defeating the Trojans with the help of AJax

AJAX

	Asynchronus Javascript And Xml

	System created to send data to a server in the background of a page without having to reload the page or wait for the server to acknowledge the change

	Not a language.

	It is a combination of technologies combined: ex: javascript, html, DOM and XML

	Ajax calls can send data to a server using GET or POST, and then catch the data sent by the server in response.

	Originally, XML was the only supported format for sending/receiving data, but now many formats are used, including JSON and plain text.

	AJAX calls can be made via the XMLHttpRequest javascript object

	Using jquery for AJAX
		The jquery library provides clean wrapper functions for making AJAX calls

	$.ajax( <SETTINGS> );
		Settings is an associative array containing all the information required to make the given ajax call.

	Notable settings keys:
		url: server target link

		type: Method ("POST" vs "GET")

		data: data to be sent

		success: function to be called if the server responds
			This function can take an argument if the server sends data in responses
	$.ajax({
		url: "/foo",
		type: "GET",
		data: "Look it's information!",
		success: function(d) {
			console.log(d);
		}
	});

		jquery also has $.get() and $.post() wrappers
			$.get( <url>, (data), <callback function> );
			
			ex:
				$.get( "/foo/", (data), function(d) { console.log(d); });





ex:

Javascript side:
var post = function( e ) {
	var input = document.getElementById("input").value;

	$.ajax({
		url: '/upcase/',
		type: "GET",
		data: { "text": input },
		success: function( d ) {
			var h = document.getElementById("h");
			d = JSON.parse(d)
			h.innerHTML = d['result'];
		}
	});
};
				
Flask side:
data = request.args.get(...
result = ...
json.dumps(result)


1/12/17
Systems

server update: move sd = server_setup() since, unlike pipes, sd doesn't get removed

client update: don't need bind() (more useful for UDP) for tcp (connect R/W)


cs lab computer: 149.89.150.1xx
			151
			160
			161


2/1/17
Graphics

Aim: Bits o' pixels?

How would you represent color data if you only had the following amount of space for each pixel?


1) 1 bit (black/white - or whatever single color)
2) 2 bits (single color + intensity)
3) 3 bits (RGB)
4) 4 bits (RGB + intensity for all)
5) 6 bits (RGB + intensity for each)

color depth = number of bits used per pixel

Image File Formats:
Lossless, lossy (some loss of information, not exact representation)
compressed (shrinked), uncompressed (raw data)

.jpeg = compressed + lossy
.png = compressed + lossless
.bmp = uncompressed + lossless
.tiff = umcompressed + lossless
.raw = uncompressed + lossless
.gif = uncompressed + lossless (related to .png)


2/2/17
Graphics

Image File Formats:
Uncompressed: every pixel has an entry
Compressed: fewer data points (compression algo figures it out)
Lossless: no info lost
Lossy: we don't have the original info

camera: image size would be huge if not compressed
.jpg = used frequently on web, smoothes out similar colors (doesn't lose too much data)
.png = algo of compression doesn't lend itself good w/ photos

.zip = loseless (get original back, trouble if lossy)
.png does the same

Run Length Encoding:
    GGGRPPPP
 -> 3G1R4P (got rid of 2 pixels)
    No loss of data
    Good for logos (no lighting/shading), images w/ similar colors in a row

.gif allows you to stick images together (like a loop)
 -> relies on similar encoding, the image gets smaller/pixelated to use that encoding

raster format = data corresponds to pixels
.pdf = vector format, image data is stored as a list of commands.
       used in text, diagrams, images can be stored in a container as other formats

Net PBM:
family of formats

We will be using .ppm files.
   All whitespace is the same
   2 parts to the file: header + pixel data
     Header starts w/ P3 then -> (X resolution + Y resolution + MAX color value)
     Pixel Data = RGB RGB RGB RGB...

ex: pic.ppm
P3		|-> header
10 10 255	|-> header
255 255 0 * 10 (columns)
-> * 10 rows


SoftDev

Aim: Documenting your data

NoSQL -> SQL has been around since the 70s, but other kinds of databases have popped up (graph, document based, ect)

Document-Oriented DB:
	Records are stored as documents.

	Each document contains all the data that is associated with the given record, in key-value pairs (fields).

	E.g. storing a db of students, each row becomes a standalone document.

	Do not need to specify the type of data put into each field.

	Fields can contain many different kinds of data, including lists and dictionaries.

	Documents that are meant to be stored together are put into collections.

	Documents in the same collection do not need to have the same fields.

code for MongoDB looks like json

{
	_id: OjectId(...,
	title: ...,
	description: ...,
	tags: [ ... ],
	likes: ...,
	comments: [
		  {
			user: ...
			message: ...
			dateCreated: ...
			like: ...
			},

			{ ....
			}
		]
}

$mongod (server process)
	can have db, which contains collections

2/3/17
Graphics

ex:
convert command: convert pic.ppm pic.png
display command: display pic.png

for{
	for {
	    
	    r
	    g
	    b

	    write: "%d %d %d\n";
	    }
}


SoftDev

Working with pymongo
	from pymongo import MongoClient

	connecting to a mongodb server and database

		   server = MongoClient(<IP>)

To access databases and collections, you can use either [] or .

   db = server['mydb']
   db = server.mydb

(stay consistent!)

students = db.students

c = db['students'] #db.students

Databases and collections are not created until a document has been added to 
them!

students.count() or db.students.count() -> number of documents

To add a document:

   1. create a dictionary
   2. insert it to the collection

      doc = { "name": "bob", "age": 65 }

      c.insert_one( doc )
      
      Can insert a list of documents with insert_many()

2/6/17
Graphics

Bresenham's Line Algorithm

[X][X][X][X][X][X][X][X][X][X][X][X] -> y = c, x = c, y = x line ez
[X][ ][ ][ ][ ][ ][X][ ][ ][ ][ ][ ]
[X][ ][ ][ ][ ][X][ ][ ][ ][ ][ ][ ]
[X][ ][ ][ ][X][ ][ ][ ][ ][ ][ ][ ]
[X][ ][ ][X][ ][ ][ ][ ][ ][ ][ ][ ]
[X][ ][X][ ][ ][ ][ ][ ][ ][ ][ ][ ]
[X][X][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ]
[X][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ]

1) y = mx + b
2) y = ((delta y)/(delta x))x + b
   0 = ((delta y)/(delta x))x + b - y
   0 = (delta y)x - (delta x)y + (delta x)b

   A = delta y
   B = - delta x
   C = (delta x) * b

   0 = Ax + By + C

   f(x,y) = Ax+By+C

   f(x,y) = 
   	    0: (x,y) is on the line
	    <0: (x,y) is above the line (y is bigger)
	    >0: (x,y) is below the line	(y is too low (we are plotting x all the time))

SoftDev

Aim: Where'd mongo put that data?

Retrieving data from mongodb

	   .find()
		Collection method that returns a cursor object that can be used to iterate through all the documents in a collection

ex:
peeps = col.find()
for p in peeps:
    print p
    ...

	.find_one()
		Collection method that returns a single document as a dictionary


	Querying a mongodb
		 .find() and .find_one() can take an argument to narrow the resulting document.

		 Queries in pymongo are formatted as documents
		 	 foo.find( {'age' : 25 } )

	Search criteria can be modified using "$and", "$or", and "$not"

	       foo.find_one( {
				'$and' : [
				       { 'name': 'bob' },
				       { 'age': 25 }
				 ]} )


	Using inequalities in searches

	      $gt, $lt, $gte, $lte, $ne

	      foo.find( {'age' : {'$gte' : 21 }} )

2/7/17
Graphics

2 possible pixels: (x+1, y), (x+1, y+1)
  	   - use midpoint (x+1, y+0.5)

	   f(x+1, y+0.5) =
	   	  >0: midpt is below the line, plot (x+1, y+1)
		  <0: midpt is above the line, plot (x+1, y)
		  0: on the line, pick either, but be consistent

	   y = y_0, x = x_0
	   for x:x_0 -> x_1
	       plot( x, y)

	       y = y_0
	       d = f(x+1, y+0.5)
	       	 if( d > 0 ):
		     y += 1		     
		 x += 1
	       
SoftDev

{
	name: bob
	age: 25
	classes: [ { code: systems, mark: 82 } ]
}

server.db.col.find( { "classes.code": "systems" } )

2/8/17
Graphics

More efficient pseudo code:

	   y = y_0, x = x_0
	   d = 2A + B (d -> 2d)
	   while x <= x_1
	       plot( x, y)

               if( d > 0 ):
		     y += 1
		     d += 2B (By = B * 1 more)		     
	       x += 1
	       d += 2A (Ax = A * 1 more)

Why:	
f(x_0 + 1, y_0 + 0.5)
Ax_0 + By_0 + C + A + 0.5B -> f(x_0, y_0) + A + 0.5B -> A + 0.5B
d = A + 0.5B
d = 2d = 2A + B

^ ^ ^ For octant I ^ ^ ^

SoftDev

Aim: upDAT(A)ing mongo

Modifying data
	  .delete_one(<QUERY>)
		deletes the first document that matches the query

	  .delete_many(<QUERY>)
		Deletes all the documents that match the query

		
	  .update_one(<QUERY>, <OPERATION>) (similar to update_many)
	        Updates doc that matches the query

	  	Operation is a document that matches an update operation:

		"$set"
			change the value of a field

		"$unset"
			remove a field

		"$inc"
			increment the value of a field

		ex:
			col.update( {'id': '4' }, {'$set': { 'name':'francis' } } )
			col.update( {'id': '4' }, {'$unset': { 'name':'' } } )

2/13/17
Graphics
		
O2:
d = 2*B + A
while(y < y1):
	plot
	if d < 0:
	   x+= 1
	   d+= 2*A

	y += 1
	d += 2*B

O8:
d = 2*A - B
while( x < x1 ):
       plot
       if d < 0:
       	  y -= 1
	  d -= 2*B

       x += 1
       d += 2*A
		
O7:
d = A - 2*B
while(y > y1):
	plot
	if d > 0:
	   x += 1
	   d += 2*A
	  
	 y -= 1
	 d -= 2 *b


SoftDev
Aim: Canvasing the area

HTML5

Redesign of HTML with a focus on making the more "modern" features of web browsers easy to work with.
Designed around javascript and a standardized DOM.
Includes built in support for audio and video playback.
Includes an element that can be directly drawn on.

Canvas

HTML5 element that provides a drawing area.
Javascript functions can draw onto a canvas element
	You must declare what context you are drawing in
	For example: 2D drawing, 3D drawing, raw bitmap rendering...

ex:
<style>
#slate: border: 1px solid black;
</style>

<h1>Canvas Fun!</h1>
<canvas width="500" height="500" id="slate"></canvas>

---------------------------------------------------------

var c = document.getElementById('slate');
var ctx = c.getContext('2d');
ctx.fillRect(50, 75, 100, 200); (xcor, ycor, width, height)
ctx.fillStyle='#ff00ff';
ctx.clearRect(200, 75, 100, 200)

2/14/17
SoftDev

Aim: Your path to success starts here!

javascript path functions
	   Paths are used to draw arbitrary shapes, including circles and curves

	   A context can keep track of one path at a time

	   The path is not drawn until stroke() is called

	   A path is considered done when a new beginPath() is called


(ctx).moveTo(x,y) -> no lines will be drawn
(ctx).lineTo(x,y)
beginPath() -> resets, begin at origin
closePath() -> results in a line from the current position to the starting position

fill() -> fills the interior of the path, will not work if the path has fewer than 3 points in it

arc(X, Y, RADIUS, START, END)
       Creates an arc path with center (X, Y) with START and END as the defining angles in radians. (0, 2 * Math.PI) = circle


12/16/17
Graphics

dilation:

draw_line( 20, 20, 100, 100 ) -> draw_line( 10, 10, 50, 50 )

store lines as points to draw (list of edges)
[ (20, 20), (100, 100), (50, 75), (300, 220) ]
 |--------------------|
	Edge

Each 2 points in the list will define a single edge
[ P_0, P_1, P_2, P_3 ... ]

To draw an image, call draw_line with 2 pts from the list at a time

Transformations can be applied to the edge list before drawing

Storing the edge list
	- Each point has 3 components (X, Y, Z)
	- Each component should be a floating point
	       x_0, x_1, x_2, ...
	       y_0, y_1, y_2, ...
	       z_0, z_1, z_2, ...

	       will be 4*N





































































































