9/28/16
SoftDev:

Aim: Requesting assistance

request object
	stores information about incoming requests.
ex:
from flask import Flask, render_template, request

ex (from flasktest.py):
print request.headers
return render_template( "form.html" )

prints:
Referer: http://127.0.0.1:5000/
Content-Length: 
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:48.0) Gecko/20100101 Firefox/48.0
Connection: keep-alive
Host: 127.0.0.1:5000
Upgrade-Insecure-Requests: 1
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Content-Type: 
Accept-Encoding: gzip, deflate

HTML:
<form action="/msg/">
<textarea name = "message" rows = "6" cols= "40"></textarea>
Python:
@app.route( "/msg/" )
def auth():
    print request.headers
    print request.args
    print request.args["message"]
    return "You good"


9/29/16
Systems:

Aim: Make so

Make
	Create compiling instructions and setup dependencies
	Standard name for the file is the makefile.

	Syntax:
		<target><dependencies>
		TAB<rules>


	strtest: stringy.c
		 gcc stringy.c

	clean:
		rm *~


	make clean would remove all emacs save files
	(files with ~ at the end of filename).


SoftDev:

Aim: Dont forget to include POSTage
DN: Open up yesterday's flask app

request.headers
	HTML headers sent from borwser
request.method
	the request method (GET/POST)
request.args
	the arguments in a query string from a GET request
request.form
	the arguments sent in a POST request
request.args and request.form are immutable dictionaries.

the u in the dictionary is unicode (string)

9/30/16
SoftDev:

Aim: Always Serve Your Passwords With A Side of Hashbrowns

Hash function
     function designed to take in an arbitrary amount of data and return a fixed
      size sequence of bits called a "hash digest" or simply, hash.

      Hash digests are useful for storing certain kinds of sensitive information.

Creating a had digest in python:
	 hashlib
		python module for generating has digests with different
		algorithms

		ex:
			md5 (bad), sha1, sha224, sha256, sha384, and sha512 (spits more bytes)

		ex:
		import hashlib
		hashlib.md5("12345")
		hashlib.md5("12345").digest() -> returns as string as attempted
		ASCII (looks messy w/ "\x")

		hashlib.md5("12345").hexdigest() -> gives savable string as hex

		hashlib.sha1("12345").hexdigest() -> longer
		hashlib.sha512("12345").hexdigest() -> much longer hex values

10/5/16
Systems:

Aim: If these files won't behave, we'll have to separate them!

DN: Demo.

crazy one line version of strlen:
int len(char *s) {
    return *s?1+len(*++s):0;
}

dw strcat:
char * dwstrcat( char * s1, char *s2 ) {
     char * p;
     p = s1 + len( s1 );
     dw strcpy(p);
     }

separate compilation:
	 You can combine multiple c files into a c program by
	 including them all in one gcc command.
	     ex:
		gcc test.c string.c foo.c woohoo.c
	 
	 You cannot have duplicate function or global variable names
	 across these files.
	 	ex: main()


one solution: make file w/o main
    ex: #include "dwstring.h"
    	void main() { ... }


	$gcc dwstrtest.c dwstring.c

SoftDev:

Aim: C is for Cookie, but Sessions are Secure

DN: Demo.

How to keep track who is logged in:

Cookies are files that websites will save to your web browser 
to store information on a local machine.

Useful for keeping track of persistent information like login credentials.

They have been around for a long time (not new).

A session is a securely signed cookie. They are encryted and cannot be modified
by the local machine.

A session object works exactly like a dictionary:
  add data to a session:
  session[KEY] = DATA
  	       ex: session['user'] = request.form('user')
 
  remove data from a session:
  session.pop(KEY)
	ex: session.pop('user')

  In order to encrypt session, need a private key in our app:
     APP.secret_key = <RANDOM STRING>

     		    get random data: os.urandom(32)
		    returns 32 random bits of data as string.

10/6/16
Systems:

Aim: malloc & free: The dynamic duo!

     gcc -c dwstring.c main.c  = compile but not make it executable

     -> dwstring.o main.o

     gcc dwstring.o main.o

     -> a.out


.o files can be linked together with .c files through gcc

gcc -o specify name of executable file

gcc would try to make file executable, gives error if "main" is missing.


void * malloc(int x)
	   memory is not initialized (allocates x bytes of memory from the heap)
	   generates generic pointer return, able to typecaste to appropriate
	   pointer.

free(void *ptr)
     releases previously allocated memory. 

void * calloc(int n, int x)
     allocates n * x bytes of memory
     ensures each bit = 0
     generates generic pointer return, able to typecaste to appropriate pointer.

void * realloc(void *ptr, int x)
     takes a pointer and changes the amount of memory allocated to given block

     ptr must be a pointer to the beginning of an allocated block of memory, but it does not have to be the original pointer.


SoftDev:

Aim: Url binding is the art of redirection

     app.secret_key = os.urandom(32)
     that could log out all of the users when app is restarted.

     ex:
     print url_for( "login" ) 
     uses associated function to build correct url
     
     redirect
     Flask fxn that will redirect a call to one route to a different response
     used in combination with url_for
     	  ex:
		redirect( url_for('login') )

10/7/16
Systems:

Aim: Structural Programing

void *
     the dynamic memory functions deal in arbitrary blocks of memory.
     There is no regular type associated with the block.

     void * is considered to be a pointer to a 1 byte block of memory,
     so pointer arithmetic will be based on 1.

ex:
  int *p;
  p = malloc( 5 * sizeof(int) ); //same as calloc( 5, sizeof(int) )

  p[0] = 2;
  printf( "p[0]: %d\n", 0[p] );

ex:
  int *ip;
  ip = (int*)malloc( 20 * sizeof(int) );


Struct
	A collection of values in a single data type
	struct { int a; char x; } s; sizeof(s) -> 8 (does units of 8 bytes)
	|-----------------------|
	  s is a type that has an int and char

	  here, s is a variable of type struct { int a; char x; }


	struct foo { int a; char x; };
	       in this example, foo is a prototype for this kind of struct
	       to be used later.

	struct foo s;
	we use the . oparator to access values in a struct:
	   ex:
		s.a

	We use the . operator to access a value iside a struct
	   s.a = 10;
	   s.x = '@';

	   . binds before *
	     to access data from a struct pointer you can either:
	     	struct foo *p;
		p = &s;
		(*p).x;
			or...
		p->x;

10/11/16
Systems:

Aim: Get Dem Bugs

What is wrong with this fxn?
struct node * insert_front( struct node * n, int i ) {
       struct node new;

       new.i = i;
       new.next = n;

       return &new;

}
The fxn is reasonably okay, but it is stack memory (new and its variables will be popped).
The only time memory is allocated dynamically is by using malloc, calloc, ect.

Typedef
	provide a new name for an existing data type
	typedef <real type> <new name>;

	ex:
		typedef unsigned long size_t;
		size_t x = 139; //really an unsigned long

		typeof short[10] list;
		list a;
		typeof char * String;

		typedef struct foo { int a; char x; } bar;


gdb (GNU Debugger)
    allows you to get detailed information about a program while it is running.

    ex: gdb a.out

    quit = quit gdb
    list = lines of code around error

    ex: break 10 = set a breakpoint at line 10

    print <VAR> = prints a variable

    backtrace = show the currect stack


valgrind
	debugging tools specializing in memory values.
	
	
	valgrind --leak-check=yes ./a.out
		 checks memory leaks


9/13/16
Softdev:

Aim: All your data are belong to us.

Relational database
	   Database that stores information as a collection of tables.

	   Field: column data in a RDB
	   Record: row in a RDB
	   Data can be linked between tables based on field values.

ex:
Students
name:	| id:
-------------------
amy	| 0
reo	| 1
emma	| 3


Class
name:	| student id:	| grade
------------------------------------
softdev	| 0		| 100
softdev	| 1		| 100


the id is related to the id in the students table


SQL (Structured Query Language)
    Standard language designed to work with relational databases.
    
    Is used for many major db programs, though the implementations may not
    (mostly are not) compatible.

    MySQL, PostgreSQL, SQLite, Oracle are different SQL implementations.

SQLite
	SQL implementation that relies entirely on functions calls in the parent 
	program. There is no database server.

	All database information is stored in a single file.

	Data is dymanically typed as values are inserted into a table.

Basic SQLite Operations
      CREATE TABLE
      	     Add a table to a database
	     CREATE TABLE <name> (<column name> <data type>, ... )
	     	    The data type will help to convert entered values to a 
		    suggested type.

		    TEXT, INTEGER, REAL, NUMERIC, BLOB
		    	  NUMERIC will default to an integer, but can be a float.
			  
			  BLOB means no suggested type.

ex:
	$ sqlite3 school.db
	...>CREATE TABLE students (name TEXT,...);
	.tables = show the tables
	INSERT INTO students VALUES ("amy", 0);
	INSERT INTO classes VALUES ("softdev", 0, NULL ); 


	Columns can be given a PRIMARY KEY attribute.
	denoting that every entry in that column is unique and cannot be NULL

	Columns can be given NOT NULL attribute, denoting that no entry can be NULL.
	INSET INTO
	      Insert a record into a table
	      INSERT INTO <name> VALUES ( <field 1>, <field 2> ... )
	      	     Will add a record to a table matching the values to the columns in order.
	
	NULL can be used in any entry.

	SELECT * FROM <name>; = select everything from a table

SQLITE Shell commands
       .quit
       .tables
       .header on|off
       .mode column|csv|list|html|insert|line|tabs

10/17/16
SoftDev:

Aim: sqlite, the low-fat alternative to SQL

python sqlite module
        import sqlite3

        connect
		open/create an sqlite database.
		
    		If the database does not exists, create it.
		   db = sqlite3.connect(<db name>).

        cursor
		Create a database cursor object that will allow you to perform
		operations of the databse.

		c = db.cursor()

        execute
		cursor method to perform the provided SQL operation, given as a
		string.
		
		c.execute( <SQL statement> )

	commit
		database method to save changes to the db

		db.commit()

	db.close()


	formatting strings in python:
		   '(' + x + ', ' + y + ') is a point'
		       =
		   '(%d, %d) is a point'%(x, y)


		   %d = decimal integer
		   %f = floating point
		   %s = string

	ex:
	command = 'INSERT INTO students VALUES ("%s", %d, %d'%(students['name'], ...

SQL SELECT Statement
    Used to get data from a database
    Creates a results table based on the query
    SELECT <column 1>, ... FROM <table 1>, ...;
    	   Will return a new table containing only the requested columns from the requested 
	   tables.

	   ex:
		SELECT name FROM students;
		SELECT * FROM students; -> gives everything from students
		SELECT name, id, code FROM students, courses; -> needs to specify
		    solution:  ->  students.id
		
10/18/16
Systems:

Aim: C, the ultimate hipster, using # decades before it was cool

ex:
	#include "link_list.h"
	->if you include 2 .h files, where one .h file includes another .h file,
	the .h file would be included twice. That is problematic.

#
	used to provide preprocessor instructions
	these directives are handled before the compler really kicks in.
	NOT regular c syntax
	gcc basically goes and copies content of the header file to where "include" is

	#include <library> or "LIBRARY"
		 link libraries to your code.

	#define <NAME> <VALUE>
		"find and replace" all occurances of NAME with VALUE

		ex:
			#define TRUE 1
				TRUE is not a variable, and doesn't get replaced in a string.

		macros:
			#define SQUARE(x) x*x (not a fxn)
			...
			int y = SQUARE(9); -> int y = 9 * 9;
			    DOESN'T COMPUTE 9*9!!

		conditional statement:
		#ifndef (if not defined) <IDENTIFIER>
		<CODE: deal with whatever is in here>
		#endif

		if the identifier has to be defined ignore all the code up until the
		endif statement.

		ex:
			#ifndef LINK_LIST_H
			#define LINK_LIST_H
			...

		also:
			#define FOO 5
			a[FOO] would be fine since FOO would be replaced.

	rand(), srand(int), sranddev()
		srand(int) = sets a seed, can be used as srand( time(t sec since epoch) )
			   time(NULL) needs #include <time.h>
		sranddev() = seed rand() with random number
			   (linux has a "file" that generates random values)
		rand() = random number generator

SoftDev:

Aim: WHERE did I put that data?

WHERE
	allows you to put restirctions on the results of a SELECT statement.
	
	ex:
		SELECT * FROM courses WHERE mark < 65;

		can use single = sign for equality test

	ex:
		select name, students.id, courses.id, code, mark from students, courses where students.id = courses.id and mark > 70;
		name        id          id          code        mark      
		----------  ----------  ----------  ----------  ----------
		kruder      1           1           systems     75        
		kruder      1           1           ceramics    99        
		dorfmeiste  2           2           softdev     75        
		dorfmeiste  2           2           ceramics    98        
		sasha       3           3           greatbooks  85        
		digweed     4           4           softdev     75        
		bassnectar  6           6           ceramics    90        
		bassnectar  6           6           systems     90        
		bassnectar  6           6           softdev     99        
		TOKiMONSTA  7           7           systems     88        
		TOKiMONSTA  7           7           softdev     85        
		jphlip      8           8           systems     98        
		alison      10          10          systems     85        
		alison      10          10          softdev     80

  
10/19/16
Systems:

Aim: A bit of operators

>> and << are binary operators.

int i = 30;
i = i>>2;
    i -> 8 (shifted values 2 bits to the "right", and added 2 0s in the front)
i = i<<2;
    i -> 28 (NOT 30)

~ negation
  flips every bit

  ex:
	00001 -> 11110

| or, & and
  ex:
	a | b -> 10010 | 01010 -> 11010
	a & b -> 10010 & 01010 -> 00010
    
    perform or/and for each pair of bits in (a, b)

^ xor
  ex:
	a ^ b

	perform xor for each pair of bits in (a, b)



10/21/16
Systems:

Aim: File this under useful information.

File permissions:
     read, write, and execute

     3 digit binary #s or 1-digit octal
     100 -> read only
     111 -> read, write, and execute


     3 permission areas: owner/user, group, other
     3-digit octal number
     	     ex: 644 -> user: read + write, group+other: read
	     default: -rw-r--r-- (644)

	     directories are also files (that contain a list of files they contain)
	     (look = read, add files = write, cd into directory = execute)
	     your id is in the metadata (data about data) in the file.


     File table:
     	  A list of all the files that is used by a program while it is running.
	  Contains basic info such as location and size.

	  has a limited size, which is a power of 2 and commonly 256 files (not bytes), and
	  getdtablesize() will return this size.

	  each file is given an integer index (starts at 0) and referred to as file descriptor
	  3 files are always open in the table:
	    	  0 or STDIN_FILENO: stdin
		  1 or STDOUT_FILENO: stdout
		  2 or STDERR_FILENO: stderr (standard error)
		  (they are links)

10/24/16
Aim: Opening up a world of possibilities

open/close
	-open: takes path string, what type of access (ex append) and optionally permission. returns int of -1 if unsuccessful.
	-close: closes file associated with handle and returns 0 if unsuccessful and -1 if error.

read/write
	-read: read( int rd, void *buf, int count )
	       read operation that attempts to read count bytes from buf associated with rd.
	-write: writes count bytes from buf to the file associated with rd.


open - <fcntl.h>
     add a file to the file table and returns its file descriptor

     if fails, -1 is returned, extra error infrmation can be found in errno.

     	errno is an int variable that can be found in <errno.h>, using strerror (in string.h)
	on errno will return a string decription of the error

	open( <PATH>, <FLAGS>, <MODE> )

	mode
		only used when creating a file. set the new files permissions using a 3 digit octal # (have a leading 0)

	ex:

	fd = open( "tester", O_RDONLY ); -> 3 if successful (0, 1, and 2 are taken)
	printf( "error: %d - %s", errno strerror(errno) );

	flags
		Determine what you plan to do with the file.
			 O_RDONLY
			 O_WRONLY
			 O_RDWR
			 O_APPEND
			 O_TRUNC
			 O_CREAT (create)
			 O_EXCL: (exclusive) only works when combined with O_CREAT, will return error if file exist

		
Each flag is a number, to combine flags we use bitwise or
     O_WRONLY = 1
     O_APPEND = 8
     O_WRONGLY | O_APPEND = 00001001


close - <unistd.h>
      remove a file from the file table (0 if successful)

      close( <FILE DESCRIPTION> );

10/24/16
Systems:

Aim:

umask - <sys/stat.h>
      set the file creation perission mask
      By default, created files are not given the exact permissions provided in the mode argument to open. Some permissions are automatically shut off. (ex: 0666 != rw-r--r--)

      Umask is applied by using bitwise negation on the mask, then bitwise and and-ing it to the mode
      new_permissions = ~umask & mode

      default umask = 0022.


So here, we get:
   umask:  000 010 010

   ~umask: 111 101 101
   & mode: 110 110 110
   -------------------
   result: 110 100 100

umask( <MASK> )
       ex: umask( 0000 ); -> everything is on
       	   umask( 0111 ); -> no execute permission

Read = take data from storage and dump into memory
read - <unistd.h>
     read( <file descriptor>, <buffer>, <amount> )
     read( fd, buff, n )

     same errno stuff ( -1, ect. ) as open
     read n bytes from the fd's file and put that data into buff

     returns the number of bytes actually read (if successful).
     buffer must be a pointer (doesn't naturally have to be a string).
     	    	 -can read integers if the file has actual numbers


write - <unistd.h>
      "twin" of read
      write n bytes from buff into fd's file

      returns the number of bytes actually written. Same errno stuff as open/read.
      buffer must be a pointer.


10/27/16
Systems:

Aim: Seek and ye shall find

-write raw byte data into txt file
       reads the int one byte at a time and attempts to read it as ASCII

lseek - <unistd.h>
      Set the current position in an open file
      lseek( <FILE DESCRIPTOR>, <OFFSET>, <WHENCE> )

      offset = # of bytes (can be negative)
      whence = where to measure offset from
      	     SEEK_SET
		offset is evaluated from the beginning of the file

	     SEEK_CUR
		offset is relative to the current position in the file

	     SEEK_END
		offset is evaluated from the end of the file

	returns the # of bytes the current position is from the beginning of the file

ex:
	int b = write(fd, r, sizeof(r) );

	lseek( fd, 0, SEEK_SET )
	int x;
	read( fd, &x, sizeof(int) );
	printf( "x: %d\n", x );
	printf( "b: %d\n", b );


	
10/28/16
Systems:

octal permission: ex: 100644
      1 is a regular file, 4 is a directory


Softdev:

Stuff we can add:
being_edited = boolean when user in middle of editing story

11/1/16
Systems:

Aim: Where fo compsci priests live? - In directory!

sprintf:
	print formated string into a string.

calloc guarantees terminanting null.

convert octal to string rwx:

perms[0] = (mode & 0b11000000) >> 6;
perms[1] = (mode & 0b111000) >> 3;
perms[2] = (mode & 0b111);

or:
110 100 100

if( mode & 256 )
    perm_string[0] = 'r';


Directories:
	A *nix directory is a file containing the names of the files within the 
directory along with basic information like file type.

	Moving files into/out of a directory means changing the directory file. 
not actually moving any data.

opendir - <dirent.h>
	open a directory file.

	This will not change the cwd, it only allows your program to read the 
contents of the directory file.

	 opendir( <PATH );

	 returns a pointer to a directory stream (DIR *)

closedir - <dirent.h>
	 closes the directory stream and frees the pointer associated with it.

	 closedir( <DIRECTORY STREAM> )

readdir - <dirent.h>

	readdir( <DIRECTORY STREAM> )

	Returns a pointer to the next entry in a directory stream, or NULL if all entries have already been returned.

	struct dirent - <sys/types.h>
	       Directory struct that contains the information stored in a directory.

SoftDev:

Aim: Extending your template knowledge.

Extending HTML templates
	  any template can be inherited by others
	  To extend a template: {% extends "<TEMPLATE>" %}

	  You can define sections to override inside.
	  ex: (content is a name)

	  {% block content %}

	  {% endblock %}
	  
Note about directories (Systems):
	// . refers to directory itself and .. refers to the parent directory
